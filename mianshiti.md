https://leetcode.cn/circle/discuss/9kE1Sc/

1 C++的三大特性
https://blog.csdn.net/weixin_41565755/article/details/89761224
① 封装：隐藏对象的属性和接口实现细节，仅仅对外提供接口
② 继承：使程序具有可重用性
③ 多态：多态体现在两个方面，动态联编和静态联编，分别指在程序运行时的多态和在程序编译时的多态。
动态联编：在子类中重写基类的虚函数，使用基类指针或者基类引用指向子类对象时，可以实现不同的功能。
静态联编：使用普通的函数重载或者函数模板的使用，实现调用同名函数实现不同功能。

2 指针和引用的区别
https://zhuanlan.zhihu.com/p/140966943
https://blog.csdn.net/weikangc/article/details/49762929
① 指针是一个变量，在逻辑上是独立的，存储的是一个地址，指向内存的一个存储单元；
引用是原变量的一个别名，不分配存储空间，跟原来的变量实质上是同一个东西。而引用r，是a的一个别名，在内存中r和a占有同一个存储单元。它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。
而引用则是某块内存的别名。
② 指针可以有多级，引用只能是一级
int** p ; // 合法
int &&a; // 不合法
③ 指针可以在定义的时候不初始化，引用必须在定义的时候初始化
④ 指针可以指向NULL，引用不可以为NULL
⑤ 指针初始化之后可以再改变，引用不可以
引用在声明定义之后就是绑定死了的，之后的=号是直接赋值过去了，并不是更改了引用对象。
⑥ sizeof的运算结果不同，64位机上，指针类型占用8个字节；sizeof（引用）：得到的是所指向的变量(对象)的大小
⑦ 自增运算意义不同
⑧ 引用是类型安全的，而指针不是 (引用比指针多了类型检查）

3 什么是多态，多态的实现方式
https://www.runoob.com/cplusplus/cpp-polymorphism.html
C++多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。
https://www.cnblogs.com/suncoolcat/p/3285687.html
在C++中通过虚函数表的方式实现多态，每个包含虚函数的类都具有一个虚函数表（virtual table），在这个类对象的地址空间的最靠前的位置存有指向虚函数表的指针。在虚函数表中，按照声明顺序依次排列所有的虚函数。
虚函数是在基类中使用关键字virtual声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。
我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。
https://zhuanlan.zhihu.com/p/104605966
在非构造函数，非析构函数的成员函数中调用「虚函数」，是多态!!!
在构造函数和析构函数中调用「虚函数」，不是多态。编译时即可确定，调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。
「多态」的关键在于通过基类指针或引用调用一个虚函数时，编译时不能确定到底调用的是基类还是派生类的函数，运行时才能确定。
可以发现有虚函数的类，多出了8个字节，在64位机子上指针类型大小正好是8个字节，这多出8个字节的指针有什么作用呢？
每一个有「虚函数」的类（或有虚函数的类的派生类）都有一个「虚函数表」，该类的任何对象中都放着虚函数表的指针。「虚函数表」中列出了该类的「虚函数」地址。
多出来的8个字节就是用来放「虚函数表」的地址。
多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。
「虚函数表的指针」指向的是「虚函数表」，「虚函数表」里存放的是类里的「虚函数」地址，那么在调用过程中，就能实现多态的特性。

纯虚函数：没有函数体的虚函数
包含纯虚函数的类叫抽象类
抽象类只能作为基类来派生新类使用，不能创建抽象类的对象；
抽象类的指针和引用可以指向由抽象类派生出来的类的对象

4 动态多态和静态多态
https://zhuanlan.zhihu.com/p/72349538
C++支持多种形式的多态，从表现的形式来看，有虚函数、模板、重载等，从绑定时间来看，可以分成静态多态和动态多态，也称为编译期多态和运行期多态。

动态多态的设计思想：对于相关的对象类型，确定它们之间的一个共同功能集，然后在基类中，把这些共同的功能声明为多个公共的虚函数接口。各个子类重写这些虚函数，以完成具体的功能。客户端的代码（操作函数）通过指向基类的引用或指针来操作这些对象，对虚函数的调用会自动绑定到实际提供的子类对象上去。
从上面的定义也可以看出，由于有了虚函数，因此动态多态是在运行时完成的，也可以叫做运行期多态，这造就了动态多态机制在处理异质对象集合时的强大威力（当然，也有了一点点性能损失）。

静态多态的设计思想：对于相关的对象类型，直接实现它们各自的定义，不需要共有基类，甚至可以没有任何关系。只需要各个具体类的实现中要求相同的接口声明，这里的接口称之为隐式接口。客户端把操作这些对象的函数定义为模板，当需要操作什么类型的对象时，直接对模板指定该类型实参即可（或通过实参演绎获得）。

相对于面向对象编程中，以显式接口和运行期多态（虚函数）实现动态多态，在模板编程及泛型编程中，是以隐式接口和编译器多态来实现静态多态。
静态多态本质上就是模板的具现化。静态多态中的接口调用也叫做隐式接口，相对于显示接口由函数的签名式（也就是函数名称、参数类型、返回类型）构成，隐式接口通常由有效表达式组成。

静态多态
优点：
由于静多态是在编译期完成的，因此效率较高，编译器也可以进行优化；
有很强的适配性和松耦合性，比如可以通过偏特化、全特化来处理特殊类型；
最重要一点是静态多态通过模板编程为C++带来了泛型设计的概念，比如强大的STL库。
缺点：
由于是模板来实现静态多态，因此模板的不足也就是静多态的劣势，比如调试困难、编译耗时、代码膨胀、编译器支持的兼容性，不能够处理异质对象集合。

动态多态
优点：
OO设计，对是客观世界的直觉认识；
实现与接口分离，可复用；
处理同一继承体系下异质对象集合的强大威力；
缺点：
运行期绑定，导致一定程度的运行时开销；
编译器无法对虚函数进行优化；
笨重的类继承体系，对接口的修改影响整个类层次；

不同点：
本质不同，静态多态在编译期决定，由模板具现完成，而动态多态在运行期决定，由继承、虚函数实现；
动态多态中接口是显式的，以函数签名为中心，多态通过虚函数在运行期实现，静态多台中接口是隐式的，以有效表达式为中心，多态通过模板具现在编译期完成。
相同点：
都能够实现多态性，静态多态/编译期多态、动态多态/运行期多态；
都能够使接口和实现相分离，一个是模板定义接口，类型参数定义实现，一个是基类虚函数定义接口，继承类负责实现；

5 虚函数的工作原理
https://blog.csdn.net/u013632755/article/details/108898214
将该函数解释为虚函数。基类定义的虚函数表明子类可以继承并实现该虚函数。虚函数的最大作用为：可以通过基类指针或引用来接收一个子类指针或者引用，并通过基类指针或引用来调用虚函数来实现相同的动作不同的实现方式，达到多态的目的。
这里涉及到静态联编和动态联编。
如果一个类的函数未声明virtual，那么在调用该函数处，编译器根据调用函数的类型进行静态联编，也就是在编译期间就已经定好调用哪个地址的函数。
如果一个类的函数通过virtual声明为了虚函数，那么该函数调用处，无法在编译期确定调用基类的函数还是派生类的函数，所以在调用函数处加入动态函数调用的代码。在程序运行时根据对象的虚函数表来查找最终调用的函数，并调用它。

对于虚函数的处理，编译器会为每个对象开始处添加一个隐藏成员，来保存一个指向函数地址数组的指针。该函数地址数组叫虚函数表(virtualfunctiontable，vtbl)，虚函数表里面存放的每个元素都是派生类与基类的每个虚函数的地址。
基类对象包含一个指针，该指针指向存放了基类声明的所有虚函数的虚函数表。派生类对象也包含一个指针指向了派生类的虚函数表，但是派生类的虚函数表从基类继承复制过来的，如果派生类重新定义了基类的虚函数，那么派生类的虚函数表中对应的虚函数地址就是派生类的虚函数地址；如果没有重新定义基类的虚函数，那么派生类的虚函数表存放的还是指向基类的虚函数地址。

6 什么是纯虚函数
https://www.php.cn/csharp-article-463856.html
虚函数和纯虚函数的区别：1、纯虚函数只有定义，没有实现；而虚函数既有定义，也有实现的代码。2、包含纯虚函数的类不能定义其对象，而包含虚函数的则可以。
纯虚函数(pure virtual)
C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。
C++中的纯虚函数更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”。
C++中的纯虚函数也是一种“运行时多态”。

7 虚函数表存放的内容
https://blog.csdn.net/T6tam/article/details/120839130
虚函数表：虚基类表是一块存储本类及基类所有的虚函数地址的空间，它由系统自动分配，不占用类的存储空间
虚函数表指针：虚函数表指针是一个指向虚函数表首地址的指针，存在类中，占用类的存储空间，虚函数表指针是提供给系统用于查找虚函数表，对于使用者来说可以忽略其实现原理；一般来说，一个类的对象只会有一个虚函数表指针，或是本类的，或是从基类继承下来的


8 虚表指针和虚函数表的存放位置
https://www.cnblogs.com/laiqun/p/5887372.html
虽然我们知道vptr指向虚函数表，那么虚函数表具体存放在内存哪个位置呢，虽然这里我们已经可以得到虚函数表的地址。实际上虚函数指针是在构造函数执行时初始化的，而虚函数表是存放在可执行文件中的。
虚函数表是class specific的，也就是针对一个类来说的，这里有点像一个类里面的staic成员变量，即它是属于一个类所有对象的，不是属于某一个对象特有的，是一个类所有对象共有的。
在每个包含有虚函数的类的对象的最前面(是指这个对象对象内存布局的最前面，至于为什么是最前面，说来话长，这里就不说了，主要是考虑到效率问题)都有一个称之为虚函数指针(vptr)的东西指向虚函数表(vtbl)，
https://blog.csdn.net/qq_28114615/article/details/98041319
C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。


9/10 C++构造函数和析构函数可以是虚函数吗
https://zhuanlan.zhihu.com/p/255274039
构造函数不可以是虚函数
当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。
虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。
vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。
如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。
因此，构造函数不可以是虚函数。
与构造函数不同，vptr已经完成初始化，析构函数可以声明为虚函数，且类有继承时，析构函数常常必须为虚函数。
若析构函数是虚函数，delete时，基类和子类都会被释放；若析构函数不是虚函数，delete时，只有基类会被释放，而子类没有释放，存在内存泄漏的隐患。

11 什么是智能指针，有哪些，实现原理
https://blog.csdn.net/zhizhengguan/article/details/112302192
因为C++使用内存的时候很容易出现野指针、悬空指针、内存泄露的问题
野指针：一些内存单元已经释放，但是之前指向它的指针还在被使用
重复释放：试图去释放已经释放的
内存泄露：应该释放的没有被释放
https://blog.csdn.net/qzt__l0ve/article/details/128345845
什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死。

C++11引入了智能指针来管理内存。有四种：
auto_ptr：已经不用了
unique_ptr：独占式指针，同一时刻只能有一个指针指向同一个对象
shared_ptr：共享式指针，同一时刻可以有多个指针指向同一个对象
weak_ptr：用来解决shared_ptr相互引用导致的死锁问题

unique_ptr能否被另一个unique_ptr拷贝呢？
不能，因为它把它的拷贝构造函数private了。但是它提供了一个移动构造函数，所以可以通过std::move将指针指向的对象交给另一个unique_ptr，转交之后自己就失去了这个指针对象的所有权，除非被显示交回

资源消耗上：
unique_ptr在默认情况下和裸指针的大小是一样的。
所以内存上没有任何的额外消耗，性能是最优的，我们大多数场景下用到的应该都是unique_ptr。
shared_ptr的内存占用是裸指针的两倍。因为除了要管理一个裸指针外，还要维护一个引用计数。因此相比于unique_ptr，shared_ptr的内存占用更高。在使用shared_ptr之前应该考虑，是否真的需要使用shared_ptr，而非unique_ptr。

https://www.zhihu.com/question/20368881

12 怎么避免循环引用

13 C++内存管理
https://blog.csdn.net/qzt__l0ve/article/details/128345845
共同点：都是从堆上申请空间，且需要手动释放

不同点：

1. malloc和free是函数，new和delete是操作符
2. malloc申请的空间不会初始化，new可以初始化
3. malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可，如果是多个对象，[]中指定对象个数即可
4. malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型
5. malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需
要捕获异常
6. 申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理

14 有哪些强制类型转换，使用的区别
https://zhuanlan.zhihu.com/p/258975506
C++支持C风格的强制转换，但是C风格的强制转换可能带来一些隐患，让一些问题难以发现。
所以C++提供了一组适用于不同场景的强制转换的函数：
static_cast：基本类型转换，低风险；
static_cast<type>(expression)
该运算符把 expression 转换为 type 类型，主要用于基本数据类型之间的转换，如把 uint 转换为 int，把 int 转换为 double 等。
需要注意的是：static_cast 没有运行时类型检查来保证转换的安全性，需要程序员来判断转换是否安全。
static_cast 还可用于类层次结构中，基类和派生类之间指针或引用的转换，但也要注意：
static_cast 进行上行转换是安全的，即把派生类的指针转换为基类的；static_cast 进行下行转换是不安全的，即把基类的指针转换为派生类的。
dynamic_cast：类层次间的上行转换或下行转换，低风险；
dynamic_cast 主要用于类层次间的上行转换或下行转换。在进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的，但在下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全。
在进行下行转换时，从基类 b2 到 d2 时，d2 会改为空指针（0x0），这正是 dynamic_cast 提升安全的功能。这个检查主要来自虚函数表。

const_cast：去 const 属性，低风险；
该运算符用来修改 expression 的 const 或 volatile 属性。这里需要注意：expression 和 type 的类型一样的。

比如下面的代码，指针 px 由于有 const 修饰，无法直接通过其修改 x 的值，但又期望能修改 x 的值时，怎么办呢？这时就需要用到 const_cast。
通过const_cast，就把 const 类型的指针 px 转换成非 const 类型的指针 py 了。

reinterpret_cast：转换不相关的类型，高风险。
该运算符可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针。

15 什么是函数重载，实现原理
https://www.cnblogs.com/leijiangtao/p/4337410.html
函数重载是指在同一作用域内，可以有一组具有相同函数名，不同参数列表（参数个数、类型、顺序）的函数，这组函数被称为重载函数。重载函数通常用来声明一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。

在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？ 
（1）C++中可以通过在函数声明前加 extern "C" 将一个函数按照 C 语言的风格来进行编译。
（2）C++语言支持函数重载。而C不支持函数重载。 

（3）函数在C中和C++中编译过的函数名字是不一样的。加上extern”C”是说明是说明C已经编译过的。
C++想要调用已经编译过的C函数，由于编译过的名字不同，是不能直接调用的，所以C++加extern“C”生命来解决这个问题。 
假设某个函数的原型为： void foo(int x, int y);该函数被C 编译器编译后在库中的名字为_foo， 而C++ 编译器则会产生像_foo_int_int 之类的名字，加上extren”C”后，就相当于告诉编译器，函数foo是个C编译后的函数，在库里应该找的是_foo,而不是_foo_int_int.

C++中函数重载底层是怎么处理的
底层的重命名机制将Add函数根据参数的个数，参数的类型，返回值的类型都做了重新命名。那么借助函数重载，一个函数就有多种命名机制。 

16 i++是原子操作吗
i++和++i都不是原子操作


17 C++类对象从编写代码定义到生成可执行文件的全过程描述
C++编写代码到可执行程序的执行，都经过了预处理、编译、汇编、链接、运行5个步骤。有时候我们也将预编译、编译和汇编统称为编译。




