https://leetcode.cn/circle/discuss/9kE1Sc/

1 C++的三大特性
https://blog.csdn.net/weixin_41565755/article/details/89761224
① 封装：隐藏对象的属性和接口实现细节，仅仅对外提供接口
② 继承：使程序具有可重用性
③ 多态：多态体现在两个方面，动态联编和静态联编，分别指在程序运行时的多态和在程序编译时的多态。
动态联编：在子类中重写基类的虚函数，使用基类指针或者基类引用指向子类对象时，可以实现不同的功能。
静态联编：使用普通的函数重载或者函数模板的使用，实现调用同名函数实现不同功能。

2 指针和引用的区别
https://zhuanlan.zhihu.com/p/140966943
https://blog.csdn.net/weikangc/article/details/49762929
① 指针是一个变量，在逻辑上是独立的，存储的是一个地址，指向内存的一个存储单元；
引用是原变量的一个别名，不分配存储空间，跟原来的变量实质上是同一个东西。而引用r，是a的一个别名，在内存中r和a占有同一个存储单元。它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。
而引用则是某块内存的别名。
② 指针可以有多级，引用只能是一级
int** p ; // 合法
int &&a; // 不合法
③ 指针可以在定义的时候不初始化，引用必须在定义的时候初始化
④ 指针可以指向NULL，引用不可以为NULL
⑤ 指针初始化之后可以再改变，引用不可以
引用在声明定义之后就是绑定死了的，之后的=号是直接赋值过去了，并不是更改了引用对象。
⑥ sizeof的运算结果不同，64位机上，指针类型占用8个字节；sizeof（引用）：得到的是所指向的变量(对象)的大小
⑦ 自增运算意义不同
⑧ 引用是类型安全的，而指针不是 (引用比指针多了类型检查）

3 什么是多态，多态的实现方式
https://www.runoob.com/cplusplus/cpp-polymorphism.html
C++多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。
https://www.cnblogs.com/suncoolcat/p/3285687.html
在C++中通过虚函数表的方式实现多态，每个包含虚函数的类都具有一个虚函数表（virtual table），在这个类对象的地址空间的最靠前的位置存有指向虚函数表的指针。在虚函数表中，按照声明顺序依次排列所有的虚函数。
虚函数是在基类中使用关键字virtual声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。
我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。
https://zhuanlan.zhihu.com/p/104605966
在非构造函数，非析构函数的成员函数中调用「虚函数」，是多态!!!
在构造函数和析构函数中调用「虚函数」，不是多态。编译时即可确定，调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。
「多态」的关键在于通过基类指针或引用调用一个虚函数时，编译时不能确定到底调用的是基类还是派生类的函数，运行时才能确定。
可以发现有虚函数的类，多出了8个字节，在64位机子上指针类型大小正好是8个字节，这多出8个字节的指针有什么作用呢？
每一个有「虚函数」的类（或有虚函数的类的派生类）都有一个「虚函数表」，该类的任何对象中都放着虚函数表的指针。「虚函数表」中列出了该类的「虚函数」地址。
多出来的8个字节就是用来放「虚函数表」的地址。
多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。
「虚函数表的指针」指向的是「虚函数表」，「虚函数表」里存放的是类里的「虚函数」地址，那么在调用过程中，就能实现多态的特性。

纯虚函数：没有函数体的虚函数
包含纯虚函数的类叫抽象类
抽象类只能作为基类来派生新类使用，不能创建抽象类的对象；
抽象类的指针和引用可以指向由抽象类派生出来的类的对象

4 动态多态和静态多态
https://zhuanlan.zhihu.com/p/72349538
C++支持多种形式的多态，从表现的形式来看，有虚函数、模板、重载等，从绑定时间来看，可以分成静态多态和动态多态，也称为编译期多态和运行期多态。

动态多态的设计思想：对于相关的对象类型，确定它们之间的一个共同功能集，然后在基类中，把这些共同的功能声明为多个公共的虚函数接口。各个子类重写这些虚函数，以完成具体的功能。客户端的代码（操作函数）通过指向基类的引用或指针来操作这些对象，对虚函数的调用会自动绑定到实际提供的子类对象上去。
从上面的定义也可以看出，由于有了虚函数，因此动态多态是在运行时完成的，也可以叫做运行期多态，这造就了动态多态机制在处理异质对象集合时的强大威力（当然，也有了一点点性能损失）。

静态多态的设计思想：对于相关的对象类型，直接实现它们各自的定义，不需要共有基类，甚至可以没有任何关系。只需要各个具体类的实现中要求相同的接口声明，这里的接口称之为隐式接口。客户端把操作这些对象的函数定义为模板，当需要操作什么类型的对象时，直接对模板指定该类型实参即可（或通过实参演绎获得）。

相对于面向对象编程中，以显式接口和运行期多态（虚函数）实现动态多态，在模板编程及泛型编程中，是以隐式接口和编译器多态来实现静态多态。
静态多态本质上就是模板的具现化。静态多态中的接口调用也叫做隐式接口，相对于显示接口由函数的签名式（也就是函数名称、参数类型、返回类型）构成，隐式接口通常由有效表达式组成。

静态多态
优点：
由于静多态是在编译期完成的，因此效率较高，编译器也可以进行优化；
有很强的适配性和松耦合性，比如可以通过偏特化、全特化来处理特殊类型；
最重要一点是静态多态通过模板编程为C++带来了泛型设计的概念，比如强大的STL库。
缺点：
由于是模板来实现静态多态，因此模板的不足也就是静多态的劣势，比如调试困难、编译耗时、代码膨胀、编译器支持的兼容性，不能够处理异质对象集合。

动态多态
优点：
OO设计，对是客观世界的直觉认识；
实现与接口分离，可复用；
处理同一继承体系下异质对象集合的强大威力；
缺点：
运行期绑定，导致一定程度的运行时开销；
编译器无法对虚函数进行优化；
笨重的类继承体系，对接口的修改影响整个类层次；

不同点：
本质不同，静态多态在编译期决定，由模板具现完成，而动态多态在运行期决定，由继承、虚函数实现；
动态多态中接口是显式的，以函数签名为中心，多态通过虚函数在运行期实现，静态多台中接口是隐式的，以有效表达式为中心，多态通过模板具现在编译期完成。
相同点：
都能够实现多态性，静态多态/编译期多态、动态多态/运行期多态；
都能够使接口和实现相分离，一个是模板定义接口，类型参数定义实现，一个是基类虚函数定义接口，继承类负责实现；

5 虚函数的工作原理
https://blog.csdn.net/u013632755/article/details/108898214
将该函数解释为虚函数。基类定义的虚函数表明子类可以继承并实现该虚函数。虚函数的最大作用为：可以通过基类指针或引用来接收一个子类指针或者引用，并通过基类指针或引用来调用虚函数来实现相同的动作不同的实现方式，达到多态的目的。
这里涉及到静态联编和动态联编。
如果一个类的函数未声明virtual，那么在调用该函数处，编译器根据调用函数的类型进行静态联编，也就是在编译期间就已经定好调用哪个地址的函数。
如果一个类的函数通过virtual声明为了虚函数，那么该函数调用处，无法在编译期确定调用基类的函数还是派生类的函数，所以在调用函数处加入动态函数调用的代码。在程序运行时根据对象的虚函数表来查找最终调用的函数，并调用它。

对于虚函数的处理，编译器会为每个对象开始处添加一个隐藏成员，来保存一个指向函数地址数组的指针。该函数地址数组叫虚函数表(virtualfunctiontable，vtbl)，虚函数表里面存放的每个元素都是派生类与基类的每个虚函数的地址。
基类对象包含一个指针，该指针指向存放了基类声明的所有虚函数的虚函数表。派生类对象也包含一个指针指向了派生类的虚函数表，但是派生类的虚函数表从基类继承复制过来的，如果派生类重新定义了基类的虚函数，那么派生类的虚函数表中对应的虚函数地址就是派生类的虚函数地址；如果没有重新定义基类的虚函数，那么派生类的虚函数表存放的还是指向基类的虚函数地址。

6 什么是纯虚函数
https://www.php.cn/csharp-article-463856.html
虚函数和纯虚函数的区别：1、纯虚函数只有定义，没有实现；而虚函数既有定义，也有实现的代码。2、包含纯虚函数的类不能定义其对象，而包含虚函数的则可以。
纯虚函数(pure virtual)
C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。
C++中的纯虚函数更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”。
C++中的纯虚函数也是一种“运行时多态”。

7 虚函数表存放的内容
https://blog.csdn.net/T6tam/article/details/120839130
虚函数表：虚基类表是一块存储本类及基类所有的虚函数地址的空间，它由系统自动分配，不占用类的存储空间
虚函数表指针：虚函数表指针是一个指向虚函数表首地址的指针，存在类中，占用类的存储空间，虚函数表指针是提供给系统用于查找虚函数表，对于使用者来说可以忽略其实现原理；一般来说，一个类的对象只会有一个虚函数表指针，或是本类的，或是从基类继承下来的


8 虚表指针和虚函数表的存放位置
https://www.cnblogs.com/laiqun/p/5887372.html
虽然我们知道vptr指向虚函数表，那么虚函数表具体存放在内存哪个位置呢，虽然这里我们已经可以得到虚函数表的地址。实际上虚函数指针是在构造函数执行时初始化的，而虚函数表是存放在可执行文件中的。
虚函数表是class specific的，也就是针对一个类来说的，这里有点像一个类里面的staic成员变量，即它是属于一个类所有对象的，不是属于某一个对象特有的，是一个类所有对象共有的。
在每个包含有虚函数的类的对象的最前面(是指这个对象对象内存布局的最前面，至于为什么是最前面，说来话长，这里就不说了，主要是考虑到效率问题)都有一个称之为虚函数指针(vptr)的东西指向虚函数表(vtbl)，
https://blog.csdn.net/qq_28114615/article/details/98041319
C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。


9/10 C++构造函数和析构函数可以是虚函数吗
https://zhuanlan.zhihu.com/p/255274039
构造函数不可以是虚函数
当类中声明虚函数时，编译器会在类中生成一个虚函数表，虚函数表是一个存储成员函数指针的数据结构。
虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中，当存在虚函数时，每个对象都有一个指向虚函数的指针（vptr指针）。在实现多态的过程中，父类和派生类都有vptr指针。
vptr的初始化：当对象在创建时，由编译器对vptr指针进行初始化。在定义子类对象时，vptr先指向父类的虚函数表，在父类构造完成之后，子类的vptr才指向自己的虚函数表。
如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化。
因此，构造函数不可以是虚函数。
与构造函数不同，vptr已经完成初始化，析构函数可以声明为虚函数，且类有继承时，析构函数常常必须为虚函数。
若析构函数是虚函数，delete时，基类和子类都会被释放；若析构函数不是虚函数，delete时，只有基类会被释放，而子类没有释放，存在内存泄漏的隐患。

11 什么是智能指针，有哪些，实现原理
https://blog.csdn.net/zhizhengguan/article/details/112302192
因为C++使用内存的时候很容易出现野指针、悬空指针、内存泄露的问题
野指针：一些内存单元已经释放，但是之前指向它的指针还在被使用
重复释放：试图去释放已经释放的
内存泄露：应该释放的没有被释放
https://blog.csdn.net/qzt__l0ve/article/details/128345845
什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死。

C++11引入了智能指针来管理内存。有四种：
auto_ptr：已经不用了
unique_ptr：独占式指针，同一时刻只能有一个指针指向同一个对象
shared_ptr：共享式指针，同一时刻可以有多个指针指向同一个对象
weak_ptr：用来解决shared_ptr相互引用导致的死锁问题

unique_ptr能否被另一个unique_ptr拷贝呢？
不能，因为它把它的拷贝构造函数private了。但是它提供了一个移动构造函数，所以可以通过std::move将指针指向的对象交给另一个unique_ptr，转交之后自己就失去了这个指针对象的所有权，除非被显示交回

资源消耗上：
unique_ptr在默认情况下和裸指针的大小是一样的。
所以内存上没有任何的额外消耗，性能是最优的，我们大多数场景下用到的应该都是unique_ptr。
shared_ptr的内存占用是裸指针的两倍。因为除了要管理一个裸指针外，还要维护一个引用计数。因此相比于unique_ptr，shared_ptr的内存占用更高。在使用shared_ptr之前应该考虑，是否真的需要使用shared_ptr，而非unique_ptr。

https://www.zhihu.com/question/20368881

12 怎么避免循环引用

13 C++内存管理
https://blog.csdn.net/qzt__l0ve/article/details/128345845
共同点：都是从堆上申请空间，且需要手动释放

不同点：

1. malloc和free是函数，new和delete是操作符
2. malloc申请的空间不会初始化，new可以初始化
3. malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可，如果是多个对象，[]中指定对象个数即可
4. malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型
5. malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需
要捕获异常
6. 申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理

14 有哪些强制类型转换，使用的区别
https://zhuanlan.zhihu.com/p/258975506
C++支持C风格的强制转换，但是C风格的强制转换可能带来一些隐患，让一些问题难以发现。
所以C++提供了一组适用于不同场景的强制转换的函数：
static_cast：基本类型转换，低风险；
static_cast<type>(expression)
该运算符把 expression 转换为 type 类型，主要用于基本数据类型之间的转换，如把 uint 转换为 int，把 int 转换为 double 等。
需要注意的是：static_cast 没有运行时类型检查来保证转换的安全性，需要程序员来判断转换是否安全。
static_cast 还可用于类层次结构中，基类和派生类之间指针或引用的转换，但也要注意：
static_cast 进行上行转换是安全的，即把派生类的指针转换为基类的；static_cast 进行下行转换是不安全的，即把基类的指针转换为派生类的。
dynamic_cast：类层次间的上行转换或下行转换，低风险；
dynamic_cast 主要用于类层次间的上行转换或下行转换。在进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的，但在下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全。
在进行下行转换时，从基类 b2 到 d2 时，d2 会改为空指针（0x0），这正是 dynamic_cast 提升安全的功能。这个检查主要来自虚函数表。

const_cast：去 const 属性，低风险；
该运算符用来修改 expression 的 const 或 volatile 属性。这里需要注意：expression 和 type 的类型一样的。

比如下面的代码，指针 px 由于有 const 修饰，无法直接通过其修改 x 的值，但又期望能修改 x 的值时，怎么办呢？这时就需要用到 const_cast。
通过const_cast，就把 const 类型的指针 px 转换成非 const 类型的指针 py 了。

reinterpret_cast：转换不相关的类型，高风险。
该运算符可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针。

15 什么是函数重载，实现原理
https://www.cnblogs.com/leijiangtao/p/4337410.html
函数重载是指在同一作用域内，可以有一组具有相同函数名，不同参数列表（参数个数、类型、顺序）的函数，这组函数被称为重载函数。重载函数通常用来声明一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。

在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？ 
（1）C++中可以通过在函数声明前加 extern "C" 将一个函数按照 C 语言的风格来进行编译。
（2）C++语言支持函数重载。而C不支持函数重载。 

（3）函数在C中和C++中编译过的函数名字是不一样的。加上extern”C”是说明是说明C已经编译过的。
C++想要调用已经编译过的C函数，由于编译过的名字不同，是不能直接调用的，所以C++加extern“C”生命来解决这个问题。 
假设某个函数的原型为： void foo(int x, int y);该函数被C 编译器编译后在库中的名字为_foo， 而C++ 编译器则会产生像_foo_int_int 之类的名字，加上extren”C”后，就相当于告诉编译器，函数foo是个C编译后的函数，在库里应该找的是_foo,而不是_foo_int_int.

C++中函数重载底层是怎么处理的
底层的重命名机制将Add函数根据参数的个数，参数的类型，返回值的类型都做了重新命名。那么借助函数重载，一个函数就有多种命名机制。 

16 i++是原子操作吗
i++和++i都不是原子操作

17 C++类对象从编写代码定义到生成可执行文件的全过程描述
C++编写代码到可执行程序的执行，都经过了预处理、编译、汇编、链接、运行5个步骤。有时候我们也将预编译、编译和汇编统称为编译。

18 类对象的内存分布与生存周期
https://blog.csdn.net/dxpqxb/article/details/102794132
C++程序的内存格局通常分为四个区：全局数据区(data area)，代码区(code area)，栈区(stack area)，堆区(heap area)(即自由存储区)。
全局数据区存放全局变量，静态数据和常量。所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。

在类的定义时，
类的成员函数被放在代码区。
类的静态成员变量在全局数据区。
非静态成员变量在类的实例内，实例在栈区或者堆区。
虚函数指针、虚基类指针在类的实例内，实例在栈区或者堆区。

创建与销毁
1 创建顺序：
外部静态对象or外部对象优先于main函数
2 销毁顺序
和创建顺序相反，静态对象会在main函数执行完才会销毁

内存的三种分配方式
1 从静态存储区分配
此时的内存在程序编译的时候已经分配好，并且在程序的整个运行期间都存在。全局变量，static变量等在此存储。
2 在栈区分配
相关代码执行时创建，执行结束时被自动释放。局部变量在此存储。栈内存分配运算内置于处理器的指令集中，效率高，但容量有限。
3 在堆区分配
动态分配内存。用new/malloc时开辟，delete/free时释放。生存期由用户指定，灵活。但有内存泄露等问题。

计算机网络
1 TCP和UDP 区别
https://zhuanlan.zhihu.com/p/24860273
1、基于连接与无连接；
2、对系统资源的要求（TCP较多，UDP少）；
3、UDP程序结构较简单；
4、流模式与数据报模式 ；
5、TCP保证数据正确性，UDP可能丢包；
6、TCP保证数据顺序，UDP不保证。

3 TCP如何保证可靠性和有序性
https://blog.csdn.net/sansipi/article/details/121459589
建立连接：通过三次握手建立连接，保证连接实体真实存在
序号机制：保证数据是按序、完整到达
合理分片：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。
数据校验：TCP报文头有校验和，用于校验报文是否损坏
超时重传：如果发送一直收不到应答，可能是发送数据丢失，也可能是应答丢失，发送方再等待一段时间之后都会进行重传。
流量控制：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。(TCP可以进行流量控制，防止较快主机致使较慢主机的缓冲区溢出)TCP使用的流量控制协议是可变大小的滑动窗口协议。
拥塞控制：网络层拥堵造成的拥塞，包括慢启动，拥塞避免，快速重传三种机制。

https://blog.csdn.net/qq_41306849/article/details/119827627
面向连接：意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于TCP。


4 如何使用UDP实现可靠性
https://blog.csdn.net/pangyemeng/article/details/50387078
TCP（TransmissionControl Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

UDP是User Datagram Protocol，一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。可靠性由上层应用实现，所以要实现udp可靠性传输，必须通过应用层来实现和控制。
UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。
传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。
实现确认机制、重传机制、窗口确认机制。
如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：
发送：包的分片、包确认、包的重发
接收：包的调序、包的序号确认


5 三次握手过程
https://www.cnblogs.com/Qing-840/p/9283367.html
第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； 
SYN：同步序列编号(Synchronize Sequence Numbers)
第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； 
第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.

完成三次握手,客户端与服务器开始传送数据
所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，

6 为什么不是四次握手和两次握手
https://blog.csdn.net/hgq0916/article/details/107491138

7 time_wait为什么等待2msl，time_wait过多怎么解决
https://blog.csdn.net/yzpbright/article/details/113566357

https://www.cnblogs.com/dadonggg/p/8778318.html
https://zhuanlan.zhihu.com/p/415307243

8 四次挥手过程
https://www.cnblogs.com/Qing-840/p/9283367.html
所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，
由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。
（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。
上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，

9 抓包的实现原理

https://blog.csdn.net/l61052319940708/article/details/80624900
监控其中任意一个网络节点（网卡），获取所有经过网卡中的数据，对这些数据按照网络协议进行解析，这就是抓包的基本原理。

10 Fin_wait2状态
https://zhuanlan.zhihu.com/p/496804881
https://www.cnblogs.com/langtianya/p/6648100.html

14 http 和 https 的区别
https://www.runoob.com/w3cnote/http-vs-https.html
基本概念
HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。
HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。

HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。

HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：

1、TCP 三次同步握手
2、客户端验证服务器数字证书
3、DH 算法协商对称加密算法的密钥、hash 算法的密钥
4、SSL 安全加密隧道协商完成
5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。



数据结构
1 什么是双链表

https://blog.csdn.net/C2395850595/article/details/124545423
双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。

2 BST(二叉搜索树),AVL(平衡二叉树)、RBT(红黑树)的区别
https://blog.csdn.net/qq_44918090/article/details/119966525

① 二叉搜索树(BST)

二叉查找树就是左结点小于根节点，右结点大于根节点的一种排序树，也叫二叉搜索树。也叫BST，英文Binary Sort Tree。

二叉查找树比普通树查找更快，查找、插入、删除的时间复杂度为O（logN）。但是二叉查找树有一种极端的情况，就是会变成一种线性链表似的结构。此时时间复杂度就变成了O（N），为了解决这种情况，出现了二叉平衡树。

② 平衡二叉树(AVL)
平衡二叉树全称平衡二叉搜索树，也叫AVL树。是一种自平衡的树。
AVL树也规定了左结点小于根节点，右结点大于根节点。并且还规定了左子树和右子树的高度差不得超过1。这样保证了它不会成为线性的链表。AVL树的查找稳定，查找、插入、删除的时间复杂度都为O（logN），但是由于要维持自身的平衡，所以进行插入和删除结点操作的时候，需要对结点进行频繁的旋转。

③ RBT(红黑树)
红黑树也叫RBT，RB-Tree。是一种自平衡的二叉查找树，它的节点的颜色为红色和黑色。它不严格控制左、右子树高度或节点数之差小于等于1。也是一种解决二叉查找树极端情况的数据结构。
红黑树性能总结：
① 对于完全随机的数据，普通的二分搜索树很好用。
缺点：极端情况退化成链表（或者高度不平衡）
② 对于查询较多的使用情况，AVL树很好用。
红黑树牺牲平衡性（2logn高度）。
红黑树统计性能更优（综合增删改查所有操作）
有序底层TreeSet、TreeMap都是红黑树

3 B Tree和B+ Tree的区别
https://blog.csdn.net/XZQ_STUD/article/details/112907790

4 map和unordered_map 的区别
https://www.cnblogs.com/yimeixiaobai1314/p/14375195.html
① 底层实现的数据结构不同
数据结构其实是两种类型最为根本的区别，其他的不同都是这种区别产生的结果。
map是基于红黑树结构实现的。红黑树是一种平衡二叉查找树的变体结构，它的左右子树的高度差有可能会大于1。所以红黑树不是严格意义上的平衡二叉树AVL，但对之进行平衡的代价相对于AVL较低，其平均统计性能要强于AVL。红黑树具有自动排序的功能，因此它使得map也具有按键（key）排序的功能，因此在map中的元素排列都是有序的。在map中，红黑树的每个节点就代表一个元素，因此实现对map的增删改查，也就是相当于对红黑树的操作。对于这些操作的复杂度都为O(logn)，复杂度即为红黑树的高度。

unordered_map是基于哈希表（也叫散列表）实现的。散列表是根据关键码值而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。散列表使得unordered_map的插入和查询速度接近于O(1)（在没有冲突的情况下），但是其内部元素的排列顺序是无序的。

map：基于红黑树，元素有序存储，复杂度与树高相同，即O(logn)。
unordered_map：基于散列表，元素无序存储，复杂度依赖于散列函数产生的冲突多少，但大多数情况下其复杂度接近于O(1)。


存储空间：unordered_map的散列空间会存在部分未被使用的位置，所以其内存效率不是100%的。而map的红黑树的内存效率接近于100%。
查找性能的稳定性：map的查找类似于平衡二叉树的查找，其性能十分稳定。例如在1M数据中查找一个元素，需要多少次比较呢？20次。map的查找次数几乎与存储数据的分布与大小无关。而unordered_map依赖于散列表，如果哈希函数映射的关键码出现的冲突过多，则最坏时间复杂度可以达到是O(n)。因此unordered_map的查找次数是与存储数据的分布与大小有密切关系的，它的效率是不稳定的。


map：
优点：
    map元素有序（这是map最大的优点，其元素的有序性在很多应用中都会简化很多的操作）；
    其红黑树的结构使得map的很多操作都可在O(logn)下完成；
    map的各项性能较为稳定，与元素插入顺序无关；
    map支持范围查找。
    缺点：
    占用的空间大：红黑树的每一个节点需要保存其父节点位置、孩子节点位置及红/黑性质，因此每一个节点占用空间大。
    查询平均时间不如unordered_map。
适用场景：
    元素需要有序；
    对于单次查询时间较为敏感，必须保持查询性能的稳定性，比如实时应用等等。
unordered_map
优点：
    查询速度快，平均性能接近于常数时间O(1)；
缺点：
    元素无序；
    unordered_map相对于map空间占用更大，且其利用率不高；
    查询性能不太稳定，最坏时间复杂度可达到O(n)。
适用场景：
    要求查找速率快，且对单次查询性能要求不敏感。

在需要元素有序性或者对单次查询性能要求较为敏感时，请使用map，其余情况下应使用unordered_map。
因此在需要使用字典结构进行算法编程的大部分情况下，都需要使用unordered_map而不是map。


操作系统
1 进程和线程的区别
https://cloud.tencent.com/developer/article/1688297
基本概念：

进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；
线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。

进程是资源分配的最小单位，线程是CPU调度的最小单位；
系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。

通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预

进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。

进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉

2 进程间通信方式
https://cloud.tencent.com/developer/article/1688297
进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。
2.2 信号量semaphore
信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

特点：
    信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
    信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
    每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
    支持信号量组。

2.3 信号signal

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

2.4 共享内存（Shared Memory）

它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等

特点：

    共享内存是最快的一种IPC，因为进程是直接对内存进行存取
    因为多个进程可以同时操作，所以需要进行同步
    信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

3.套接字SOCKET：

socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。

线程间通信的方式:
临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；
互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作进程间通信的方式：



1 自旋锁和互斥锁区别
https://blog.csdn.net/qq_37935909/article/details/108625508
① 互斥锁
性能开销成本：两次线程上下文切换的成本。
1、当线程加锁失败时，内核将线程的状态从【运行】切换到睡眠状态，然后把CPU切换给其他线程运行；
2、当锁被释放时，之前睡眠状态的线程会变成就绪状态，然后内核就会在合适的时间把CPU切换给该线程运行；

线程切换的上下文？
当两个线程属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。
上下切换的耗时大概在几十纳秒到几微秒之间，如果锁住的代码执行时间比较短，可能上下文切换的时间比锁住的代码执行时间还要长。
若是能确定被锁住的代码执行时间很短，就不应该使用互斥锁，而应该选择自旋锁。

② 自旋锁
自旋锁通过CPU提供的CAS，在用户态完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些开销小一些。






